\documentclass[12pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}% ermöglich die direkte Eingabe der Umlaute 
\usepackage[T1]{fontenc} % das Trennen der Umlaute
\usepackage[ngerman]{babel} % hiermit werden deutsche Bezeichnungen genutzt 
\usepackage{csquotes} 	% Gänsefüßchen nach gesetzter Sprache
\usepackage{graphicx}	% Bilder
\usepackage{subcaption}	% Für die Subfigures
\usepackage{geometry}	% Seitengröße
\usepackage[backend=biber,style=numeric,]{biblatex}	% Fürs Literatursverzeichis
\usepackage{glossaries}
\usepackage{caption}
\usepackage{chngcntr}
\makeglossaries
\counterwithin{figure}{section}
\counterwithin{table}{section}
\usepackage{titling}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[onehalfspacing]{setspace}
\geometry{
  left=2.5cm,
  right=2.5cm,
  top=2.5cm,
  bottom=2cm,
  bindingoffset=5mm
}
\loadglsentries{glossary.bib}
\addbibresource{literatur.bib}

%------------------------
% Deckblatt Titel und co.
%------------------------

\pretitle{\begin{center}
\begin{figure}[h!]
	\begin{subfigure}{0.2\linewidth}
		\includegraphics[scale=1]{DHBWLogo.png} 
	\end{subfigure}
	\hspace*{\fill}
	\begin{subfigure}{0.3\linewidth}
    	\includegraphics[scale=0.25]{YellowMap.png}
	\end{subfigure}
\end{figure}
}
\posttitle{\end{center}}
\title{\Large{\bfseries Containerisierung und horizontale Skalierung}\vspace{1cm}
	\large PRAXISBERICHT\vspace{1cm}}
\author{
	\normalsize für die Prüfung zum\\\\
	\normalsize Bachelor of Engineering/Bachelor of Science\\\\
	\normalsize des Studiengangs Informatik\\
	\normalsize Studienrichtung Angewandte Informatik\\\\
	\normalsize an der\\\\
	\normalsize Dualen Hochschule Baden-Württemberg Karlsruhe\\\\\\
	\normalsize von\\\\
	\normalsize Jakob Jonathan Heitzmann
}
\date{\today}
\begin{document}

\maketitle
\vspace*{\fill}
\thispagestyle{empty}

%----------------
% Deckblatt unten
%----------------


\begin{tabular}{p{5cm}ll}
	Matrikelnummer & 9119328\\
	Kurs & TINF19B4\\
	Ausbildungsfirma & YellowMap AG, & Karlsruhe\\
	Betreuer & Markus Lind\\
	Prof. Jörn Eisenbiegler
\end{tabular}

\newpage

%--------------------------
% Eidesstattliche Erklärung
%--------------------------

\section*{Erkl\"arung}

Gem\"a\ss\ \S\ 5 (3) der ''Studien- und Pr\"ufungsordnung DHBW Technik'' vom 29. September 2017 erkl\"are ich, Jakob Jonathan Heitzmann, dass ich die vorliegende Arbeit selbstst\"andig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel verwendet habe, sowie dass die physisch-vorliegende Version der Digitalen identisch ist.\\

\hspace*{0.5cm}
Karlsruhe, den \today

\vspace*{2cm}

\begin{tabular}{@{}l@{}}\hline
\rule{0pt}{2ex}
Jakob Jonathan Heitzmann
\end{tabular}
\newpage

%---------------
%Zusammenfassung
%---------------

\begin{abstract}
\begin{center}
Zusammenfassung
\end{center}
In dieser Arbeit geht es um meine Tätigkeit bei der YellowMap AG und was ich in den ersten zwei Semestern gelernt und getan habe. Diese Arbeit beschränkt sich aber in erster Linie auf die Bemühungen, die zur Umwandlung des Serversystems auf ein verteiltes System galten.
\end{abstract}
\newpage

\tableofcontents
\addcontentsline{toc}{section}{Inhaltsverzeichnis}
\newpage
\listoffigures
\addcontentsline{toc}{section}{Abbildungsverzeichnis}
\newpage
\listoftables
\addcontentsline{toc}{section}{Tabellenverzeichnis}
\newpage
\printglossary
\addcontentsline{toc}{section}{Glossar}
\newpage

%-----------------------------------------------------------------------------------------------
%Hier beginnt das eigentliche Inhalt des Dokuments. (Davor nur Deckblatt bis Inhaltsverzeichniss)
%-----------------------------------------------------------------------------------------------

\section{Einf\"uhrung}
Ziel der Arbeit ist es vorzuzeigen was ich in den ersten beiden Semestern meines Studiums bei der YellowMap AG gelernt und getan habe. Dabei wird sich auf die Gesamtheit der Bemühungen begrenzt, die dazu galten die bestehende Serverstruktur zu brechen und einen Prototypen zu konzeptionieren, mit wessen Vorbild man das bestehende System in ein verteiltes System wandeln könnte. Zu diesem Zweck musste ich mich mit verschiedenen Arten der Serverkommunikation und Containerisierung beschäftigen.

\subsection{Kontextuelle Betrachtung der Rahmenbedingungen}

YellowMap entwickelt und hostet in erster Linie Kartenanwendungen, bietet Entwicklern aber auch mit einer Java-Script-API die Möglichkeit mit wenig Selbstaufwand selbst eine solche Anwendung zu Entwickeln. Dabei laufen die Dienste mit allen gängigen großen Kartenanbietern so wie Google, OSM, Bing und sogar Baidu. Exemplarische Lösungen, die YellowMap anbietet, sind zum Beispiel die FilialFinder, mit denen alle Filialen eines Klienten auf dessen Webseite angezeigt werden können. Die Anzeige erfolgt natürlich auf einer Karte. Gesucht wird für gewöhnlich mit einer Umkreissuche auf den Standort des Gerätes. Die Gefundenen Filialen können auch neben der Karte auch auf einer Liste sortiert ausgegeben werden.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.55]{YmFF.png}
	\caption{FilialFinder}
\end{figure}

Im umrissenen Zeitraum habe ich viele Tätigkeiten besonders in den Bereichen Backend und Testing übernommen. Doch auch ein paar kleinere Aufgaben im Bereich Frontend fielen mir zu. Gearbeitet habe ich mit .NET Core, Gatling, HTML, CSS, JavaScript, Docker, Kubernetes und RabbitMQ. 
Darunter war die Entwicklung eines Dienstes, der dazu fähig ist Termindaten von einer Datenbank zu ziehen und diese dann auf kleinen E-Paper-Bildschirmen anzuzeigen was vollständig in C\# realisiert wurde. Auch entwickelte ich zu Demozwecken Testwebseiten die Funktionen der JavaScript API präsentieren sollten. Ein anderes Projekt war die Realisierung von Stresstests auf ein schon bestehendes Projekt mittels Gatling. Dafür musste ich mich in die Programmiersprache Scala und Maven einarbeiten. 

Das Projekt, auf das ich in diesem Bericht näher eingehen möchte war nun die Entwicklung eines Prototyps zur Containerisierung und automatischen horizontalen Skalierung mittels Docker und Kubernetes, sowie die Entwicklung eines Prototyps für die Serverkommunikation mit Message Broker mittels RabbitMQ. Für diese Aufgabe wurden diese Technologien vorgegeben. 

\subsection{Das bisherige Serverdesign}
Das bestehende System wurde entworfen damit viele Anwendungen unabhängig voneinander entwickelt werden können ohne, dass jede Funktionalität in jeder neuen Anwendung auch neu geschrieben werden müsste. Dazu greifen alle Projekte auf dieselbe Schnittstelle zu, diese bietet dann die einzelnen Funktionalitäten in einem einheitlichen Format. Diese Art der Kommunikation ermöglicht es unabhängig von Art der Anwendung die Anbindung an die internen Dienste sicherzustellen. Eine Anfrage eines Projekts auf diese Schnittstelle landet als erstes am Proxy der Core, also zu Deutsch dem Kern, hier wird die Anfrage angenommen und auf erster Ebene Authentifiziert. Diese Anfrage wird dann an den System Call weitergeleitet. Hier befindet sich der Partnerschalter. Er reichert die Daten der Anfrage mit den Daten zum gelieferten Partner aus der Datenbank an. Heißt er schaut zum Beispiel von welchem Provider der Partner seine Daten beziehen möchte und trifft dem entsprechend Vorkehrungen, dass die Daten in den folgenden Aufrufen und Aktionen richtig weitergegeben und verarbeitet werden. Auch wird hier die auszuführende Aktion ermittelt und der dazugehörige Befehl in Form eines Commands oder einer Command-Group. Ein Command reichert die Daten nun weiter an und reicht dann an einen Provider spezifische Command-Action weiter, die die angefragte Aktion dann ausführt. In Abbildung 7.1 sehen wir so einen Aufruf, der dann aber Beispielshalber auf ein Lagacy-System zugreift, das wiederum selbst eine eigene Command-Action besitzt, die die Anfrage dann letztendlich ausführt. Diese Legacy-Systeme werden aber in dieser Arbeit nicht weiter betrachtet, da diese nicht mehr aktiv weiterentwickelt werden.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=2]{YmSysReq.png}
	\caption{Beispielanfrage}
\end{figure}

Das System ist also kein Monolithisches, da es aus vielen Einzelprojekten besteht, die größtenteils unabhängig von einander agieren können, aber es ist ebenso kein verteiltes System, da sich trotz des modularen Designs alles auf demselben Server befindet.

\section{Serverkommunikation mit Message Broker} \label{rabbit}
Zuerst begann ich den Prototypen für die Serverkommunikation mittels Message Broker zu konzeptionieren. Der Message Broker sollte eine neue interne Schnittstelle zwischen dem Serversystem und dem Legacy-System etablieren, da diese zuvor via normale HTTP-Aufrufe, die über das externe Netz gingen, realisiert wurde. Dies benötigte das Herauslösen eigenständiger Komponenten des Legacy-Systems und die Umwandlung dieser in sogenannte Microservices. Im Hinblick auf die späteren Änderungen, die noch an dem System vorgenommen werden sollten, sollte auch die Möglichkeit betrachtet werden, die Protokollierung von Systemdaten über den Message Broker auf eine Vielzahl von Empfängersystemen zu ermöglichen. 

\subsection{Funktion eines Message Brokers}
Ein Message Broker ist ein System zur Nachrichtenübertragung und Nachrichtenverteilung. Dafür fungiert der Message Broker selbst als der zentrale Umschlagplatz von dem aus Nachrichten Empfangen und Verteilt werden. Ebenso übersetzt er aktiv zwischen verschiedenen Protokollen\cite{mesBro}. Er stellt eine Art Middleware da, was bedeutet, dass er als neutrale Komponente im System nur für die Vermittlung von Information zwischen anderen Komponenten verantwortlich ist.

\subsection{Anwendungsspezifische Betrachtung}
In Hinblick auf die Containerisierung ist das Prinzip eines Message Brokers mehr als nützlich.
Ein Message Broker kann einen Nachrichten-Pool schaffen, den er kontinuierlich und gezielt mit Nachrichten versorgt, die dann von den letztendlichen Verbrauchern konsumiert werden können. Dadurch schafft man ein Netz von Geräten, die nur noch eine zentrale Adresse kennen müssen und dadurch dynamischer und unabhängiger voneinander agieren können. 

\begin{figure}[h!]
	\centering
	\includegraphics[scale=1.8]{MesBroSys.png}
	\caption{Serversystem mit Message Broker}
\end{figure}

In Abbildung 8.1 sehen wir wie der Message Broker seine Funktion als Middleware zwischen einem API-Gateway und mehreren Diensten erfüllt.  

\subsection{RabbitMQ}
RabbitMQ ist ein Open-Source-Message-Broker, der das Advanced-Message-Queuing-Protokoll (AMQP) unterstützt und sogar um einige nützliche Funktionalitäten erweitert\cite{rabExt}.
Darunter ist eine grafische Managementoberfläche und Unterstützung für Remote-Procedure-Calls (RPC). Dies sind beides Funktionen die enormst praktisch für die vorgesehene Verwendung sind.

Mittels grafischer Managementoberfläche wird die Fehlersuche immens einfacher Gestaltet. Sie zeigt an, an welchen Endpunkten Nachrichten eingetroffen sind, wie viele es sind, ob ein Endpunkt gemeldete Konsumenten hat und vieles mehr. Mit ihr kann man ebenfalls sämtliche Konstrukte selbst erzeugen und die Nachrichten im allgemeinen Verwalten. 

Ein RPC ermöglicht es uns eine Funktion auf einem anderen Gerät auszuführen und ebenso dessen Wert zurückgeliefert zu bekommen. Was genau das ist was wir in einem verteilten System wollen.

\subsubsection{Grundlegende Funktionsweise}

RabbitMQ stellt in erster Linie einen Serverdienst, eine Managementoberfläche und Nutzerschnittstellen zur Verfügung. Der Serverdienst nimmt Nachrichten entgegen und Verwaltet diese. 
Er besitzt Exchanges und Queues. Ein Exchange nimmt eine Nachricht entgegen und verteilt diese an eine oder mehrere Queues, die ein Binding auf den jeweiligen Exchange haben. 

\begin{figure}[h!]
	\centering
	\includegraphics[scale=1]{P2C.jpg}
	\caption{Produzent, Queue und Konsument}
\end{figure}

Es gibt verschiedene Arten von Exchanges, die Nachrichten auf verschiedene Weise verteilen. 

Ein Fanout-Exchange sendet die Nachricht an jede Queue, mit der er ein Binding besitzt. 

Ein Direct-Exchange sendet eine Nachricht nur an eine Queue, wenn der Routing-Key der Nachricht mit dem Namen einer Queue übereinstimmt, die natürlich auch ein Binding auf dem Exchange haben muss.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=1.65]{exchanges.png}
	\caption{Pruduzent, Exchange und Queue}
\end{figure}

Ein Topic-Exchange wiederum verteilt an mehrere Queues in seinem Binding. Dabei dürfen die Queues keinen willkürlichen Namen tragen, sondern müssen einem gewissen Namensmuster Folgen, dass teilweise den Routing-Key der zu empfangenden Nachrichten reflektieren soll. Wenn zum Beispiel der Routing-Key einer Nachricht core.failure.critical wäre, so wäre auch *.*.critical ein Name, unter dem eine Queue diese Nachricht empfangen würde. Dabei steht das Sternchen als Platzhalter für jedes mögliche Wort. Die Punkte reflektieren die Punkte im Routing-Key. Eine Raute ist dabei ein Platzhalter für mehrere Wörter, also über Punkte hinaus. 

Der Standard-Exchange ist ein Direct-Exchange und wird innerhalb des Codes mit Hilfe einer Leeren Zeichenkette ausgewählt. Er ist auch notwendigerweise mit allen Queues verbunden.

Ein Exchange wird von Produzenten befüllt. Ein Produzent erzeugt Nachrichten und schickt diese an Exchanges damit diese dann an einer oder mehreren Queues konsumiert werden.

Eine Queue ist ein Speicher, der Nachrichten zwischenspeichert und nach dem First-in-First-Out (FIFO)-Prinzip an Konsumenten verteilt. Sie sind Anlaufstelle für Konsumenten. 

Ein Konsument meldet sich bei einer Queue und wird dort in eine Liste von Konsumenten aufgenommen. So wird er dann von dem Server mit Nachrichten bedient. Wird eine Nachricht konsumiert kann ein Konsument diesen Vorgang bestätigen falls der Produzent es wünscht. Das heißt wiederum aber auch, dass der Produzent nun auch auf die Antwort des Konsumenten wartet und ihn somit potenziell Blockiert.

Eine Nachricht wird in RabbitMQ mit vielen Attributen abgesendet. Sie folgt in erster Linie dem AMQP, doch RabbitMQ hat diese um einige Funktionen erweitert. So kommt zum Beispiel das Attribut reply\_to mit. In diesem Attribut kann eine Antwortadresse für zum Beispiel den Absender hinzugefügt werden. Dieses Attribut wird später im Remote-Procedure-Call benutzt. Sonst kommt offensichtlicherweise Informationen über die Zieladresse und den Ziel-Exchange, der Routing-Key und natürlich auch die eigentliche Nachricht, dem Body, mit.

Die Managementoberfläche und Nutzerschnittstellen bieten eine Plattform, von der man mit dem Serverdienst wie beschrieben interagieren kann.

\subsubsection{Remote-Procedure-Call (RPC)}
Der RPC ist ein Muster, das uns ermöglicht auf eine Nachricht eine entsprechende Antwort zu bekommen, wie bei einem Funktionsaufruf. 

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.74]{RPC.jpg}
	\caption{RPC}
\end{figure}

Für dieses Muster verwenden wir zuerst einen normalen Produzenten, den wir jedoch um die Attribute reply\_to und correlation\_id erweitern. Wir setzten die Antwort-Queue auf einen zufälligen Namen, den wir uns von RabbitMQ generieren lassen. Mit der correlation\_id machen wir das ähnlich. Dann öffnen wir einen Konsumenten auf eben diese Queue.

Der Konsument nimmt nun ganz normal diese Nachricht an und ließt das reply\_to-Attribut aus. Und sendet eine Antwort auf diese Queue.

Der Sender konsumiert diese Antwort und überprüft die corelation\_id. Wenn diese nun übereinstimmt gibt er den Antworttext zurück und trennt die Verbindung zu der Queue, die, wenn diese die Eigenschaft auto\_delete gesetzt hat, sich dann von alleine löscht.

\subsection{Implementierung}

Bevor ich beginnen konnte meinen Prototypen zu bauen musste ich eigenständige Teile in der Serverarchitektur erkennen und isolieren. Meine Methodik lässt sich darauf beschränken, dass ich das Projekt kopierte, die zu isolierende Funktion im Code ausmachte und nun alles entfernte, was offensichtlich keine Abhängigkeit zu der Funktion hatte. Nun konnte ich den Aufruf durch die alte Schnittstelle löschen und mit dem Aufruf durch RabbitMQ ersetzen. Ich benutzte dafür das RPC-Muster, das ich zuvor schon beschrieben habe. 

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{RPCWorkerWhite.png}
	\caption{RPC-Empfänger}
\end{figure}

In Abbildung 2.5 sehen wir 

Den Sender, oder auch RPC-Client genannt, implementierte ich hierzu an der Stelle, an welcher auch normalerweise der HTTP-Aufruf für eben diese Funktion stattfand. Ich wandelte die Daten in eine JSON-Zeichenkette, was das Rückübersetzen in ein Objekt vereinfachte. Da es sich um komplexe Objekte handelte, die nicht nur Basisdatentypen als Werte hatten, musste ich den Übersetzer der JSON-Bibliothek, die ich verwendete, anpassen, so dass das innere Objekt der Anfrage mit übersetzt werden konnte. Dann machte ich mich langsam daran, gezielt überflüssigen Code zu entfernen, solange bis nur noch der Kern der Funktion über war.

\newpage
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.7]{RPCKlientWhite.png}
	\caption{RPC-Sender}
\end{figure}

Den Prototypen zum Fanout-Exchange implementierte ich als Dead-Letter-Exchange, eine Art Exchange, den man bei der Initialisierung einer Queue angeben kann. An ihn werden Nachrichten gesendet, wenn diese Nachrichten eine in der Queue gesetzten Time-To-Live (TTL) überschreiten.

\section{Containerisierung mit \gls{Docker}} \label{docker}
Docker ist ein Werkzeug zur Erstellung und Verwaltung von Containern. Container sind kleine voneinander unabhängige Umgebungen in denen Programme lauffähig und von außerhalb gezielt erreichbar sind. Sie werden dafür eingesetzt eine Anwendung von äußeren Einflüssen zu befreien. Ihre Prämisse lautet, dass wenn eine Anwendung auf einem System funktioniert, funktioniert sie auf allen Systemen. Ein Container hat für gewöhnlich nur das nötigste installiert um lauffähig zu sein, alles andere wird vom Entwickler selbst beigesteuert.

\subsection{Was Containerisierung ist?}

\subsection{Warum Docker?}

\subsection{Umsetzung}

\section{Skalierung mit \gls{Kubernetes}} \label{kubernetes}
Kubernetes ist ein Werkzeug zur Erstellung und Verwaltung von Containerclustern. Containercluster sind Verbünde von einzelnen Containern die 

\subsection{Was ist Skalierung?}

\subsection{Warum \gls{Kubernetes}?} 

\subsection{Umsetzung}

\section{Stand des Projekts} \label{project_status}

\section{Fazit}\label{conclusion}
Und jetzt spitzt das warme Blut aus dem Hals der letzten Sau. Und mit ihr stirbt ein kleines Stück Geschichte unserer Stadt. Der Sau ist es egal, doch wir wissen es genau. Der Bagger macht viel mehr als nur den alten Schlachthof platt. 

\newpage

%-----------------------------------------------------------------
% Ab hier => Literaturverzeichnis + temporäre Kommentare und Tests
%-----------------------------------------------------------------

\printbibliography
\addcontentsline{toc}{section}{Literaturverzeichnis}
\end{document}