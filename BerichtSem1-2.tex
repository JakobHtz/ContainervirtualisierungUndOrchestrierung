\documentclass[12pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}% ermöglich die direkte Eingabe der Umlaute 
\usepackage[T1]{fontenc} % das Trennen der Umlaute
\usepackage[ngerman]{babel} % hiermit werden deutsche Bezeichnungen genutzt 
\usepackage{csquotes} 	% Gänsefüßchen nach gesetzter Sprache
\usepackage{graphicx}	% Bilder
\usepackage{subcaption}	% Für die Subfigures
\usepackage{geometry}	% Seitengröße
\usepackage[backend=biber,style=numeric,]{biblatex}	% Fürs Literatursverzeichis
\usepackage{glossaries}
\usepackage{caption}
\usepackage{chngcntr}
\makeglossaries
\counterwithin{figure}{page}
\counterwithin{table}{page}
\usepackage{titling}
\geometry{
  left=3cm,
  right=3cm,
  top=2cm,
  bottom=4cm,
  bindingoffset=5mm
}
\loadglsentries{glossary.bib}
\addbibresource{literatur.bib}

%------------------------
% Deckblatt Titel und co.
%------------------------

\pretitle{%
\begin{center}
  \begin{figure}[h!]
	\begin{subfigure}{0.4\linewidth}
		\includegraphics[scale=0.25]{DHBWKarlsruhe.jpg} 
	\end{subfigure}
	\hspace*{\fill}
	\begin{subfigure}{0.4\linewidth}
    	\includegraphics[scale=0.25]{YellowMap.png}
	\end{subfigure}
\end{figure}
}
\posttitle{\end{center}}
\title{\Large{\bfseries Containerisierung und horizontale Skalierung}\vspace{1cm}
	\large PRAXISBERICHT\vspace{1cm}}
\author{
	\normalsize für die Prüfung zum\\\\
	\normalsize Bachelor of Engineering/Bachelor of Science\\\\
	\normalsize des Studiengangs Informatik\\
	\normalsize Studienrichtung Angewandte Informatik\\\\
	\normalsize an der\\\\
	\normalsize Dualen Hochschule Baden-Württemberg Karlsruhe\\\\\\
	\normalsize von\\\\
	\normalsize Jakob Jonathan Heitzmann
}
\date{\today}
\begin{document}

%-------
% Bilder
%-------

\maketitle
\vspace*{\fill}
\thispagestyle{empty}

%----------------
% Deckblatt unten
%----------------


\begin{tabular}{p{5cm}rr}
	Matrikelnummer & 9119328\\
	Kurs & TINF19B4\\
	Ausbildungsfirma & YellowMap AG & Karlsruhe\\
	Betreuer & Markus Lind
\end{tabular}

\newpage

%--------------------------
% Eidesstattliche Erklärung
%--------------------------

\section*{Erkl\"arung}

Gem\"a\ss\ \S\ 5 (3) der ''Studien- und Pr\"ufungsordnung DHBW Technik'' vom 29. September 2017 erkl\"are ich, Jakob Jonathan Heitzmann, dass ich die vorliegende Arbeit selbstst\"andig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel verwendet habe, sowie dass die physisch-vorliegende Version der Digitalen identisch ist.\\

\hspace*{0.5cm}
Karlsruhe, den \today

\vspace*{2cm}

\begin{tabular}{@{}l@{}}\hline
\rule{0pt}{2ex}
Jakob Jonathan Heitzmann
\end{tabular}
\newpage

%---------------
%Zusammenfassung
%---------------

\begin{abstract}
In dieser Arbeit geht es um meine Tätigkeit bei der YellowMap AG und was ich in den ersten zwei Semestern gelernt und getan habe. Diese Arbeit beschränkt sich aber in erster Linie auf die Bemühungen, die zur Umwandlung des Serversystems auf ein verteiltes System galten.
\end{abstract}
\newpage

\tableofcontents
\addcontentsline{toc}{section}{Inhaltsverzeichnis}
\newpage

%-----------------------------------------------------------------------------------------------
%Hier beginnt das eigentliche Inhalt des Dokuments. (Davor nur Deckblatt bis Inhaltsverzeichniss)
%-----------------------------------------------------------------------------------------------

\section{Einf\"uhrung}
Ziel der Arbeit ist es vorzuzeigen was ich in den ersten beiden Semestern meines Studiums bei der YellowMap AG gelernt und getan habe. Dabei wird sich auf die Gesamtheit der Bemühungen begrenzt, die dazu galten die bestehende Serverstruktur zu brechen und einen Prototypen zu konzeptionieren, mit wessen Vorbild man das bestehende System in ein verteiltes System wandeln könnte. Zu diesem Zweck musste ich mich mit verschiedenen Arten der Serverkommunikation und Containerisierung beschäftigen.

\subsection{Kontextuelle Betrachtung der Rahmenbedingungen}

YellowMap entwickelt und hostet in erster Linie Kartenanwendungen, bietet Entwicklern aber auch mit einer Java-Script-API die Möglichkeit mit wenig Selbstaufwand selbst eine solche Anwendung zu Entwickeln. Dabei laufen die Dienste mit allen gängigen großen Kartenanbietern so wie Google, OSM, Bing und sogar Baidu. Exemplarische Lösungen, die YellowMap anbietet, sind zum Beispiel die FilialFinder, mit denen alle Filialen eines Klienten auf dessen Webseite angezeigt werden können. Die Anzeige erfolgt natürlich auf einer Karte. Gesucht wird für gewöhnlich mit einer Umkreissuche auf den Standort des Gerätes. Die Gefundenen Filialen können auch neben der Karte auch auf einer Liste sortiert ausgegeben werden.

\begin{figure}[h!]
	\includegraphics[scale=0.55]{YmFF.png}
	\caption{FilialFinder}
\end{figure}

Im umrissenen Zeitraum habe ich viele Tätigkeiten besonders in den Bereichen Backend und Testing übernommen. Doch auch ein paar kleinere Aufgaben im Bereich Frontend fielen mir zu. Gearbeitet habe ich mit .NET Core, Gatling, HTML, CSS, JavaScript, Docker, Kubernetes und RabbitMQ. 
Darunter war die Entwicklung eines Dienstes, der dazu fähig ist Termindaten von einer Datenbank zu ziehen und diese dann auf kleinen E-Paper-Bildschirmen anzuzeigen was vollständig in C\# realisiert wurde. Auch entwickelte ich zu Demozwecken Testwebseiten die Funktionen der JavaScript API präsentieren sollten. Ein anderes Projekt war die Realisierung von Stresstests auf ein schon bestehendes Projekt mittels Gatling. Dafür musste ich mich in die Programmiersprache Scala und Maven einarbeiten. 

Das Projekt, auf das ich in diesem Bericht näher eingehen möchte war nun die Entwicklung eines Prototypen zur Containerisierung und automatischen horizontalen Skalierung mittels Docker und Kubernetes, sowie die Entwicklung eines Prototypen für die Serverkommunikation mit Message Broker mittels RabbitMQ. Für diese Aufgabe wurden diese Technologien vorgegeben. 

\subsection{Das bisherige Serverdesign}
Das bestehende System wurde entworfen damit viele Anwendungen unabhängig voneinander entwickelt werden können ohne dass jede Funktionalität in jeder neuen Anwendung auch neu geschrieben werden müsste. Dazu greifen alle Projekte auf die selbe Schnittstelle zu, diese bietet dann die einzelnen Funktionalitäten in einem einheitlichen Format. Diese Art der Kommunikation ermöglicht es unabhängig von Art der Anwendung die Anbindung an die internen Dienste sicherzustellen. Eine Anfrage eines Projekt auf diese Schnittstelle landet als erstes am Proxy der Core, also zu deutsch dem Kern, hier wird die Anfrage angenommen und auf erster Ebene Authentifiziert. Diese Anfrage wird dann an den System Call weitergeleitet. Hier befindet sich der Partnerschalter. Er reichert die Daten der Anfrage mit den Daten zum gelieferten Partner aus der Datenbank an. Heißt er schaut zum Beispiel von welchem Provider der Partner seine Daten beziehen möchte und trifft dem entsprechend Vorkehrungen, dass die Daten in den folgenden Aufrufen und Aktionen richtig weitergegeben und verarbeitet werden. Auch wird hier die auszuführende Aktion ermittelt und der dazugehörige Befehl in Form eines Commands oder einer Command-Group. Ein Command reichert die Daten nun weiter an und reicht dann an eine Provider spezifische Command-Action weiter, die die angefragte Aktion dann ausführt. In Abbildung 7.1 sehen wir so einen Aufruf, der dann aber Beispielshalber auf einen Lagacy-System zugreift, das wiederum selbst eine eigene Command-Action besitzt, die die Anfrage dann letztendlich ausführt. Diese Legacy-Systeme werden aber in dieser Arbeit nicht weiter betrachtet, da diese nicht mehr aktiv weiterentwickelt werden. 

\newpage

\begin{figure}[h!]
	\includegraphics[scale=2]{YmSysReq.png}
	\caption{Beispielanfrage}
\end{figure}

Das System ist also kein Monolithisches, da es aus vielen Einzelprojekten besteht, die größtenteils unabhängig von einander agieren können, aber es ist ebenso kein verteiltes System, da sich trotz des modularen Designs alles auf dem selben Server befindet.

\section{Serverkommunikation mit Message Broker} \label{rabbit}
Zuerst begann ich den Prototypen für die Serverkommunikation mittels Message Broker zu konzeptionieren. Der Message Broker sollte eine neue interne Schnittstelle zwischen dem Serversystem und dem Legacy-System etablieren, da diese zuvor via normale HTTP-Aufrufe, die über das externe Netz gingen, realisiert wurde. Dies benötigte das Herauslösen eigenständiger Komponenten des Legacy-Systems und die Umwandlung dieser in sogenannte Microservices. Im Hinblick auf die späteren Änderungen, die noch an dem System vorgenommen werden sollten, sollte auch die Möglichkeit betrachtet werden, die Protokollierung von Systemdaten über den Message Broker auf eine Vielzahl von Empfängersystemen zu ermöglichen. 

\subsection{Funktion eines Message Brokers}
Ein Message Broker ist ein System zur Nachrichtenübertragung und Nachrichtenverteilung. Dafür fungiert der Message Broker selbst als der zentrale Umschlagplatz von dem aus Nachrichten Empfangen und Verteilt werden. Ebenso übersetzt er aktiv zwischen verschiedenen Protokollen\cite{mesBro}. Er stellt eine Art Middleware da, was bedeutet, dass er als neutrale Komponente im System nur für die Vermittlung von Information zwischen anderen Komponenten verantwortlich ist.

\subsection{Anwendungsspezifische Betrachtung}
In Hinblick auf die Containerisierung ist das Prinzip eines Message Brokers mehr als nützlich.
Ein Message Broker kann einen Nachrichten-Pool schaffen, den er kontinuierlich und gezielt mit Nachrichten versorgt, die dann von den letztendlichen Verbrauchern konsumiert werden können. Dadurch schafft man ein Netz von Geräten, die nur noch eine zentrale Adresse kennen müssen und dadurch dynamischer und unabhängiger voneinander agieren können. 

\begin{figure}[h!]
	\includegraphics[scale=1.8]{MesBroSys.png}
	\caption{Serversystem mit Message Broker}
\end{figure}

In Abbildung 8.1 sehen wir wie der Message Broker seine Funktion als Middleware zwischen einem API-Gateway und mehreren Diensten erfüllt.  

\subsection{RabbitMQ}
RabbitMQ ist ein Open-Source-Message-Broker, der das Advanced-Message-Queuing-Protokoll (AMQP) unterstützt und sogar um einige nützliche Funktionalitäten erweitert\cite{rabExt}.
Darunter ist eine grafische Managementoberfläche und Unterstützung für Remote-Procedure-Calls (RPC). Dies sind beides Funktionen die enormst praktisch für die vorgesehene Verwendung sind.

Mittels grafischer Managementoberfläche wird die Fehlersuche immens einfacher Gestaltet. Sie zeigt an, an welchen Endpunkten Nachrichten eingetroffen sind, wie viele es sind, ob ein Endpunkt gemeldete Konsumenten hat und vieles mehr. Mit ihr kann man ebenfalls sämtliche Konstrukte selbst erzeugen und die Nachrichten im allgemeinen Verwalten. 

Ein RPC ermöglicht es uns eine Funktion auf einem anderen Gerät auszuführen und ebenso dessen Wert zurückgeliefert zu bekommen. Was genau das ist was wir in einem verteilten System wollen.

\subsubsection{Grundlegende Funktionsweise}

RabbitMQ stellt in erster Linie einen Serverdienst, eine Managementoberfläche und Nutzerschnittstellen zur Verfügung. Der Serverdienst nimmt Nachrichten entgegen und Verwaltet diese. 
Er besitzt Exchanges und Queues. Ein Exchange nimmt eine Nachricht entgegen und verteilt diese an eine oder mehrere Queues, die ein Binding auf den jeweiligen Exchange haben. Es gibt verschiedene Arten von Exchanges, die Nachrichten auf verschiedene Weise verteilen. Ein Fanout-Exchange sendet die Nachricht an jede Queue, mit der er ein Binding besitzt. Ein Direct-Exchange sendet eine Nachricht nur an eine Queue, wenn der Routing-Key der Nachricht mit dem Namen einer Queue übereinstimmt, die natürlich auch ein Binding auf dem Exchange haben muss.
Ein Topic-Exchange wiederum verteilt an mehrere Queues in seinem Binding. Dabei dürfen die Queues keinen willkürlichen Namen tragen, sondern müssen einem gewissen Namensmuster Folgen, dass teilweise den Routing-Key der zu empfangenden Nachrichten reflektieren soll. Wenn zu Beispiel der Routing-Key einer Nachricht core.failure.critical wäre, so wäre auch *.*.critical ein Name, unter dem eine Queue diese Nachricht empfangen würde. Dabei steht das Sternchen als Platzhalter für jedes mögliche Wort. Die Punkte reflektieren die Punkte im Routing-Key. 

\subsection{Implementierung}

\section{Containerisierung mit \gls{Docker}} \label{docker}
Docker ist ein Werkzeug zur Erstellung und Verwaltung von Containern. Container sind kleine voneinander unabhängige Umgebungen in denen Programme lauffähig und von außerhalb gezielt erreichbar sind.

\subsection{Was Containerisierung ist?}

\subsection{Warum Docker?}

\subsection{Umsetzung}

\section{Skalierung mit \gls{Kubernetes}} \label{kubernetes}
Kubernetes ist ein Werkzeug zur Erstellung und Verwaltung von Containerclustern. Containercluster sind Verbünde von einzelnen Containern die 

\subsection{Was ist Skalierung?}

\subsection{Warum \gls{Kubernetes}?} 

\subsection{Umsetzung}

\section{Stand des Projekts} \label{project_status}

\section{Fazit}\label{conclusion}

\newpage

%-----------------------------------------------------------------
% Ab hier => Literaturverzeichnis + temporäre Kommentare und Tests
%-----------------------------------------------------------------

\printbibliography
\addcontentsline{toc}{section}{Literaturverzeichnis}
\newpage
\printglossary
\addcontentsline{toc}{section}{Glossar}
\newpage
\listoffigures
\addcontentsline{toc}{section}{Abbildungsverzeichnis}
\newpage
\listoftables
\addcontentsline{toc}{section}{Tabellenverzeichnis}
\end{document}