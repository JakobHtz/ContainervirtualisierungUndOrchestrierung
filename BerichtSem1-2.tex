\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}% ermöglich die direkte Eingabe der Umlaute 
\usepackage[T1]{fontenc} % das Trennen der Umlaute
\usepackage[ngerman]{babel} % hiermit werden deutsche Bezeichnungen genutzt 
\usepackage{csquotes} 	% Gänsefüßchen nach gesetzter Sprache
\usepackage{graphicx}	% Bilder
\usepackage{subcaption}	% Für die Subfigures
\usepackage{geometry}	% Seitengröße
\usepackage[backend=biber,style=numeric,]{biblatex}	% Fürs Literatursverzeichis
\usepackage{glossaries}
\makeglossaries
\geometry{
  left=3cm,
  right=3cm,
  top=2cm,
  bottom=4cm,
  bindingoffset=5mm
}
\loadglsentries{glossary.bib}
\addbibresource{literatur.bib}

%------------------------
% Deckblatt Titel und co.
%------------------------

\title{\Large{\bfseries Containerisierung und horizontale Skalierung}\vspace{1cm}
	\large PRAXISBERICHT\vspace{1cm}}
\author{für die Prüfung zum\\\\
	Bachelor of Engineering/Bachelor of Science\\\\
	des Studiengangs Informatik\\
	Studienrichtung Angewandte Informatik\\\\
	an der\\\\
	Dualen Hochschule Baden-Württemberg Karlsruhe\\\\\\
	von\\\\
	Jakob Jonathan Heitzmann
}
\date{\today}

\begin{document}

%-------
% Bilder
%-------

\begin{figure}[t!]
	\begin{subfigure}{0.4\linewidth}
		\includegraphics[scale=0.25]{DHBWKarlsruhe.jpg} 
	\end{subfigure}
	\hspace*{\fill}
	\begin{subfigure}{0.4\linewidth}
    	\includegraphics[scale=0.25]{YellowMap.png}
	\end{subfigure}
	%\caption[https://www.aldi-sued.de/filialen/]{DHBW} Caption für Abbildungsverzeichnis
\end{figure}

\maketitle
\vspace*{\fill}

%----------------
% Deckblatt unten
%----------------


\begin{tabular}{p{5cm}rr}
	Matrikelnummer & 9119328\\
	Kurs & TINF19B4\\
	Ausbildungsfirma & YellowMap AG & Karlsruhe\\
	Betreuer & Markus Lind
\end{tabular}

\newpage

%--------------------------
% Eidesstattliche Erklärung
%--------------------------

\section*{Erkl\"arung}

Gem\"a\ss\ \S\ 5 (3) der ''Studien- und Pr\"ufungsordnung DHBW Technik'' vom 29. September 2017 erkl\"are ich, Jakob Jonathan Heitzmann, dass ich die vorliegende Arbeit selbstst\"andig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel verwendet habe, sowie dass die physisch-vorliegende Version der Digitalen identisch ist.\\

\hspace*{0.5cm}
Karlsruhe, den \today

\vspace*{2cm}

\begin{tabular}{@{}l@{}}\hline
\rule{0pt}{2ex}
Jakob Jonathan Heitzmann
\end{tabular}
\newpage

%---------------
%Zusammenfassung
%---------------

\begin{abstract}
In dieser Arbeit geht es um meine Tätigkeit bei der YellowMap AG und was ich in den ersten zwei Semestern gelernt und getan habe. Diese Arbeit beschränkt sich aber in erster Linie auf die Bemühungen, die zur Umwandlung des Serversystems auf ein verteiltes System galten.
\end{abstract}
\newpage

\tableofcontents
\newpage

%-----------------------------------------------------------------------------------------------
%Hier beginnt das eigentliche Inhalt des Dokuments. (Davor nur Deckblatt bis Inhaltsverzeichniss)
%-----------------------------------------------------------------------------------------------

\section{Einf\"uhrung}
Ziel der Arbeit ist es vorzuzeigen was ich in den ersten beiden Semestern meines Studiums bei der YellowMap AG gelernt und getan habe. Dabei wird sich auf die Gesamtheit der Bemühungen begrenzt, die dazu galten die bestehende Serverstruktur zu brechen und einen Prototypen zu konzeptionieren, mit wessen Vorbild man das bestehende System in ein verteiltes System wandeln könnte. Zu diesem Zweck musste ich mich mit verschiedenen Arten der Serverkommunikation und Containerisierung beschäftigen.

\subsection{Kontextuelle Betrachtung der Rahmenbedingungen}

YellowMap entwickelt und hostet in erster Linie Kartenanwendungen, bietet Entwicklern aber auch mit einer Java-Script-API die Möglichkeit mit wenig Selbstaufwand selbst eine solche Anwendung zu Entwickeln. Dabei laufen die Dienste mit allen gängigen großen Kartenanbietern so wie Google, OSM, Bing und sogar Baidu. Exemplarische Lösungen, die YellowMap anbietet, sind zum Beispiel die FilialFinder, mit denen alle Filialen eines Klienten auf dessen Webseite angezeigt werden können. Die Anzeige erfolgt natürlich auf einer Karte. Gesucht wird für gewöhnlich mit einer Umkreissuche auf den Standort des Gerätes. Die Gefundenen Filialen können auch neben der Karte auch auf einer Liste sortiert ausgegeben werden.\\
Im umrissenen Zeitraum habe ich viele Tätigkeiten besonders in den Bereichen Backend und Testing übernommen. Doch auch ein paar kleinere Aufgaben im Bereich Frontend fielen mir zu. Gearbeitet habe ich mit .NET Core, Gatling, HTTP, CSS, JavaScript, Docker, Kubernetes und RabbitMQ. 
Darunter war die Entwicklung eines Dienstes, der dazu fähig ist Termindaten von einer Datenbank zu ziehen und diese dann auf kleinen E-Paper-Bildschirmen anzuzeigen was vollständig in C\# realisiert wurde. Auch entwickelte ich zu Demozwecken Testwebseiten die Funktionen der JavaScript API präsentieren sollten. Ein anderes Projekt war die Realisierung von Stresstests auf ein schon bestehendes Projekt mittels Gatling. Dafür musste ich mich in die Programmiersprache Scala und Maven einarbeiten. 

Das Projekt, auf das ich in diesem Bericht näher eingehen möchte war nun die Entwicklung eines Prototypen zur Containerisierung und automatischen horizontalen Skalierung mittels Docker und Kubernetes, sowie die Entwicklung eines Prototypen für die Serverkommunikation mit Message Broker mittels RabbitMQ. Für diese Aufgabe wurden diese Technologien vorgegeben. 

\paragraph{Das bisherige Serverdesign}
Das bestehende System wurde entworfen damit viele Anwendungen unabhängig voneinander entwickelt werden können ohne dass jede Funktionalität in jeder neuen Anwendung auch neu geschrieben werden müsste. Dazu greifen alle Projekte auf die selbe Schnittstelle zu, diese bietet dann die einzelnen Funktionalitäten in einem einheitlichen Format. Diese Art der Kommunikation ermöglicht es unabhängig von Art der Anwendung die Anbindung an die internen Dienste sicherzustellen. Eine Anfrage eines Projekt auf diese Schnittstelle landet als erstes am Proxy der Core, also zu deutsch dem Kern, hier wird die Anfrage angenommen und auf erster Ebene Authentifiziert. Diese Anfrage wird dann an den System Call weitergeleitet. Hier befindet sich der Partnerschalter. Er reichert die Daten der Anfrage mit den Daten zum gelieferten Partner aus der Datenbank an. Heißt er schaut zum Beispiel von welchem Provider der Partner seine Daten beziehen möchte und trifft dem entsprechend Vorkehrungen, dass die Daten in den folgenden Aufrufen und Aktionen richtig weitergegeben und verarbeitet werden. Auch wird hier die auszuführende Aktion ermittelt und der dazugehörige Befehl in Form eines Commands oder einer Command-Group. Ein Command reichert die Daten nun weiter an und reicht dann an eine Provider spezifische Command-Action weiter, die die angefragte Aktion dann ausführt. In Abb. 1 sehen wir so einen Aufruf, der dann aber Beispielshalber auf einen Lagacy-System zugreift, das wiederum selbst eine eigene Command-Action besitzt, die die Anfrage dann letztendlich ausführt. Diese Legacy-Systeme werden aber in dieser Arbeit nicht weiter betrachtet, da diese nicht mehr aktiv weiterentwickelt werden. 

Das System ist also kein Monolithisches, da es aus vielen Einzelprojekten besteht, die größtenteils unabhängig von einander agieren können, aber es ist ebenso kein verteiltes System, da sich trotz des modularen Designs alles auf dem selben Server befindet.

\section{Serverkommunikation mit Message Broker} \label{rabbit}
Die erste Aufgabe, die ich bekam, war es die interne Serverkommunikation sicherstellen zu können. Damit sollten die zur Zeit getrennt laufenden Server nicht mehr darauf zurückgreifen sich über das externe Netz via \gls{HTTP}-Anfragen zu verständigen. Im Hinblick auf die späteren Änderungen, die am System vorgenommen werden mussten um es zu verteilen, entschied man sich für einen Message Broker.

\subsection{Was macht ein Message Broker?}
Ein Message Broker ist ein System zur Nachrichtenübertragung und Nachrichtenverteilung. Dafür fungiert der Message Broker selbst als der zentrale Umschlagplatz von dem aus Nachrichten Empfangen und Verteilt werden. Ebenso übersetzt er aktiv zwischen verschiedenen Protokollen\cite{mesBro}. 

\subsection{Warum ein Message Broker? Warum RabbitMQ?}
\paragraph{Warum ein Message Broker}
In Hinblick auf die Containerisierung ist das Prinzip eines Message Brokers mehr als nützlich.
Ein Message Broker kann einen Nachrichten-Pool schaffen, den er kontinuierlich und gezielt mit Nachrichten versorgt, die dann von den letztendlichen Verbrauchern konsumiert werden können. Dadurch schafft man ein Netz von Geräten, die nur noch eine zentrale Adresse kennen müssen und dadurch dynamischer und unabhängiger voneinander agieren können. 

\paragraph{Warum RabbitMQ}
Die Entscheidung dieses Prinzip mit \gls{RabbitMQ} umzusetzen war eine Einfache. \gls{RabbitMQ} unterstützt nicht nur die komplette Spezifikation des \gls{AMQP}, es fügt auch nützliche Funktionen hinzu\cite{rabExt}.

\subsection{Implementierung}

\section{Containerisierung mit \gls{Docker}} \label{docker}
Docker ist ein Werkzeug zur Erstellung und Verwaltung von Containern. Container sind kleine voneinander unabhängige Umgebungen in denen Programme lauffähig und von außerhalb gezielt erreichbar sind.

\subsection{Was Containerisierung ist?}

\subsection{Warum Docker?}

\subsection{Umsetzung}

\section{Skalierung mit \gls{Kubernetes}} \label{kubernetes}
Kubernetes ist ein Werkzeug zur Erstellung und Verwaltung von Containerclustern. Containercluster sind Verbünde von einzelnen Containern die 

\subsection{Was ist Skalierung?}

\subsection{Warum \gls{Kubernetes}?} 

\subsection{Umsetzung}

\section{Stand des Projekts} \label{project_status}

\section{Fazit}\label{conclusion}

\newpage

%-----------------------------------------------------------------
% Ab hier => Literaturverzeichnis + temporäre Kommentare und Tests
%-----------------------------------------------------------------

\printbibliography
\newpage
\printglossary
\newpage
\listoffigures
\newpage
\listoftables
\end{document}